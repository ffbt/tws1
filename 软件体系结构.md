# 软件体系结构

## 体系结构的概念

- 组件 (component) 
- 连接件 (connector)
- 约束 (constraint)

## 体系结构风格

### 为什么选择该风格

- 优点满足需求
- 缺点可容忍

### 数据流 (data flow)

##### 适用场景

* 任务由数据主导
* 事先知道数据的确切流向

##### 组件

- 输入端口
- 输出端口

##### 连接件

数据流

##### 约束

- 数据容器不能自己改变数据
- 管道是单向的
- 每一步必须在前一步结束后才能开始

#### 批处理 (batch sequential)

![1530690658666](C:\Users\dell-pc\AppData\Local\Temp\1530690658666.png)

##### 例子

编译器

#### 管道 & 过滤器 (pipes & filters)

![1530690775844](C:\Users\dell-pc\AppData\Local\Temp\1530690775844.png)

##### 组件

过滤器

##### 连接件

管道

##### 优点

1. 软件具有隐蔽性、高内聚、低耦合的特点
2. 支持功能模块的重用
3. 系统易于维护和扩展
4. 多个低级过滤器可以合成为一个高级过滤器 
5. 支持多个过滤器并发执行
6. 易于分析吞吐量、死锁等特性

##### 缺点

1. 通常导致进程成为批处理的结构
2. 不适合于交互性很强的应用
3. 需要处理同步问题
4. 数据传输无通用标准

##### 例子

- 编译器
- 媒体播放器
  - 输入：AVI 文件，包括音频和视频数据。
  - 分离器：把音频和视频数据分离为两个流，分别传给音频解码器和视频解码器。
  - 输出：音频数据传递给声卡，图像数据传递给显卡。

#### 过程控制 (process control)

##### 开环控制

系统无反馈，由人进行反馈

##### 闭环控制

![1530690833705](C:\Users\dell-pc\AppData\Local\Temp\1530690833705.png)

系统有反馈，不需要人进行反馈

- 反馈控制 (feedback)

  反馈控制器根据**受控变量**的测量值来调整过程 

- 前馈控制 (feedforward)

  通过测量**其他过程变量**，来**预计**输入变量对被控变量将产生的影响。前馈控制基于这些变量来调整过程。在实际中更有价值 

##### 适用场景

- 任务包含连续的动作、行为、状态的改变
- 不适合人参与的情况
- 一般是软硬件结合的系统

### 调用 / 返回 (call / return)

#### 主 / 子程序 (main program & subroutine)

![1530690980794](C:\Users\dell-pc\AppData\Local\Temp\1530690980794.png)

##### 适用场景

可通过过程定义的层次结构适当定义计算的应用程序 (存在层次结构)

##### 组件

程序和可见的数据

##### 连接件

过程调用和数据共享

##### 控制结构

单线程

##### 特点

- 逐步分解
- 单线程控制
- 主程序正确性受子程序正确性影响
- 只适用于可以定义一系列步骤的问题
- 子系统结构不清晰

#### 面向对象 (object oriented)

![1530691041156](C:\Users\dell-pc\AppData\Local\Temp\1530691041156.png)

##### 适用场景

中心问题是识别和保护相关信息体，特别是表示信息。OO是对现实中离散事件和个体交互的仿真，最适合模拟现实。 

##### 组件

管理者 (服务者、对象、抽象数据类型)

##### 连接件

过程调用

##### 控制结构

分散、单线程

##### 优点

- 组件和组件之间的操作以黑箱的方式进行
- 良好的隐蔽性
- 对象之间的访问是通过方法调用来实现的
- 封装完成了相关功能和属性的包装，并由对象来对它们进行管理
- 使用某个对象提供的服务并不需要知道内部是如何实现的

##### 缺点

- 对象之间的耦合度较紧，必须知道对象的标识
- 只要一个对象的标识改变了，就必须修改所有其他明确调用它的对象
- 过多的对象难以维护
- 过多的交互难以维护

#### 分层 (layered)

![1530691105454](C:\Users\dell-pc\AppData\Local\Temp\1530691105454.png)

##### 适用场景

此模式适用于涉及可以分层排列的不同服务类别的应用程序。

##### 组件

程序的集合

##### 连接件

过程调用

##### 控制结构

单线程

##### 优点

- 每层为上一层服务，使用下一层的服务
- 大的问题分解为小问题逐步解决
- 修改一层最多影响两层

##### 缺点

- 上层必须知道下层的身份，不能调整层次之间的次序
- 层层相调，影响性能

### 独立构件 (independent components)

#### 通信进程 (communicating processes)

![1530718214957](C:\Users\dell-pc\AppData\Local\Temp\1530718214957.png)

##### 适用场景

- 不同的、大量的独立计算
- 系统的正确性需要注意消息的路由与同步

##### 组件

收发消息的进程

##### 连接件

消息

##### 过程控制

每个进程都有自己的控制线程，可以在通信点暂停或继续

#### 事件系统 (event systems)

![1530719342393](C:\Users\dell-pc\AppData\Local\Temp\1530719342393.png)

##### 隐式调用 (implicit invocation)

##### 显式调用 (explicit invocation)

##### 适用场景

- 涉及松耦合的组件集合
- 反应系统
- 动态重新配置

##### 组件

在不知道信号接收者的情况下发出信号的进程

##### 连接件

已经注册了感兴趣的事件的进程的自动调用

##### 控制结构

- 分散的
- 个体组件不知道信号接收者

##### 优点

- 为软件重用提供了强大的支持。当需要将一个构件加入现存系统中时，只需将它注册到系统的事件中。新的关注者不对现有的关注者构成任何影响 。
- 为改进系统带来了方便。当用一个构件代替另一个构件时，不会影响到其它构件的接口。
- 调用可以并行
- 一个组件的崩溃不会影响到其他的组件

##### 缺点

- 构件放弃了对系统控制
- 不能保证过程被调用的顺序
- 一个构件触发一个事件时，不能确定其他构件是否会响应它
- 过程的语义必须依赖于被触发事件的上下文约束
- 系统记录每个事件的关注着，可能存在全局性能和资源管理的问题
- 间接/交互意味着性能损失

### 虚拟机 (virtual machine)

#### 解释器 (interpreter)

![1530696350539](C:\Users\dell-pc\AppData\Local\Temp\1530696350539.png)

##### 适用场景

- 无法直接使用最合适的语言或机器来执行解决方案
- 核心问题是定义表达解决方案的记号，例如脚本。

##### 组件

- 一个状态机：解释引擎
- 三个存储器
  - 正在被解释的程序
  - 被解释程序的当前状态
  - 解释引擎的当前状态

##### 连接件

- 过程调用
- 对存储区的数据访问

##### 优点

1. 可以模拟非本地功能
2. 可以模拟灾害模式
3. 提升应用程序的可移植性

##### 缺点

1. 额外的间接层次带来了系统性能的下降
2. 额外的软件层的正确性需要进行验证

#### 基于规则的系统 (rule-based system)

![1530711544396](C:\Users\dell-pc\AppData\Local\Temp\1530711544396.png)

##### 适用场景

- 规则复杂
- 把可变部分与不变部分进行分离，在前者发生变化时就不会影响后者
- 基于规则的系统：一种特殊的虚拟机，使用模式匹配搜索来寻找规则，并在正确时机应用正确的规则

##### 组件

- 一个状态机：解释引擎 (规则解释器)
- 三个存储器
  - 将要被执行的代码 (知识源)
  - 解释引擎的控制状态 (选择规则/数据)
  - 代码的当前状态 (工作内存)

##### 优点

- 降低修改业务逻辑的成本与风险
- 缩短开发时间
- 规则可在多个应用中共享

### 数据中心 (data-centered)

#### 仓库 (repository)

![1530690583704](C:\Users\dell-pc\AppData\Local\Temp\1530690583704.png)

##### 适用场景

- 共享数据
- 收集、操作、存储大量的数据
- 此模式适用于中心问题是建立，扩充和维护复杂的信息中心体系的应用程序。

##### 组件

- 中央数据结构：当前状态
- 独立构件的集合：与中央数据结构交互

##### 连接件

计算单元通过直接数据访问或过程调用与存储器交互

##### 优点

- 很容易增加数据的生产者和消费者
- 便于数据的共享

##### 缺点

- 同步
- 配置和管理
- 原子性
- 一致性
- 持久性
- 性能

##### 例子

- 数据库
- 剪贴板
- 注册表

#### 黑板 (blackboard)

![1530691795469](C:\Users\dell-pc\AppData\Local\Temp\1530691795469.png)

##### 组成

- 知识源 (专家)
  - 包含独立的、与应用程序相关的知识
  - 知识源之间不直接进行通信
  - 一个知识源只能解决问题的一部分
- 黑板数据结构
  - 按照与应用程序相关的层次来组织解决问题的数据
  - 提供接口
  - 通过不断修改黑板数据结构解决问题
- 控制 (仲裁者)
  - 控制完全由黑板的状态驱动
  - 决定下一步选用哪个知识源进行工作

##### 适用场景

- 没有直接的算法可解
  - 多种方法都可能解决问题
  - 需要多个领域的专门知识协作解决
- 不确定性
  - 数据和解决方法可能错误或变化
  - 数据中的信噪比会变化
  - 算法接口的变化
- 问题没有唯一的答案，正确答案会变化

## 模型和文档

### 4+1视图

#### 用例视图 (场景)

看系统对外提供了什么“有价值的功能” 

##### 用例图

用于显示若干角色以及这些角色与系统提供的用例之间的连接关系。 

##### 描述

##### 概述图

#### 逻辑视图

系统各部分的抽象描述

##### 类图

表示系统中的类和类与类之间的关系，它是对系统静态结构的描述

##### 对象图

描述系统运行时刻的状态

##### 序列图

用来反映若干个对象之间的动态协作关系 

##### 通信图

描述对象间的协作关系

##### 状态图

描述类的对象所有可能的状态以及事件发生时状态的转移条件。

##### 交互图

#### 过程视图

系统完成业务的过程

##### 活动图

描述满足用例要求所要进行的活动以及活动间的约束关系

#### 开发视图

系统各部分是如何组织的

##### 包图

将元素组合成更高级别的单元

##### 组件图

描述代码构件的物理结构各构件之间的依赖关系

#### 物理视图

系统的设计是如何对应到实际的

##### 部署图

定义系统中软、硬件的物理体系结构 

## 质量属性

### 质量属性场景

- 刺激源：产生刺激的实体
- 刺激：影响系统的一个状态
- 环境：刺激发生的条件
- 制品：被刺激激发的部分
- 反应：刺激发生后的结果
- 反应测量：系统响应的测量方法

### 可用性 (availability)

系统正常运行的时间比例

#### 质量属性场景

- 刺激源：内部和外部的错误和故障指示
- 刺激：发生以下类型的故障
  - 遗漏：组件无法响应输入。
  - 崩溃：该组件反复出现遗漏错误。
  - 时间：组件响应但响应是早或晚。
  - 响应：组件响应的值不正确。
- 制品：高可用性所需的资源
  - 过程
  - 存储
  - 处理器
  - 通信
- 环境：当错误或故障可能影响系统的响应时系统的状态
  - 普通
  - 降低操作
- 响应：
  - 记录日志
  - 通知用户或其他系统
  - 关闭外部的系统
  - 恢复过程中不可用
- 响应测量：
  - 可用性百分比
  - 指定修复时间
  - 系统必须可用的持续时间

#### 策略

##### 错误检测

- ping / echo
- 心跳
- 异常

##### 错误恢复

- 表决
- 主动冗余
- 被动冗余
- 备件
- shadow 操作
- 状态再同步
- 检查点/回滚

##### 错误预防

- 进程监视器
- 从服务中删除
- 事务

### 可修改性 (modifiability)

快速、低成本修改系统的能力

#### 质量属性场景

- 刺激源：
  - 用户
  - 开发者
  - 系统管理员
- 刺激：希望添加/删除/修改/改变功能，质量属性，容量
- 制品：系统用户界面，平台，环境; 与目标系统互操作的系统
- 环境：
  - 运行时
  - 编译时
  - 构建时
  - 设计时
- 响应：
  - 找到要修改的架构中的位置;
  - 进行修改而不影响其他功能;
  - 测试修改;
  - 部署修改
- 响应测量：受影响的元素的数量、精力、金钱成本，影响其他功能或质量属性的程度

#### 策略

##### 局部化修改

- 维持语义一致性
- 预期期望的变更
- 泛化模块 
- 限制可能的选择

##### 防止连锁反应

- 信息隐藏
- 维持现有的接口
- 限制通信路径
- 使用中间件

##### 推迟绑定时间

- 运行时注册
- 配置文件
- 发布 / 订阅
- 多态
- 组件替换
- 定义协议

### 性能 (performance)

当事件发生时系统在多长时间内响应

#### 质量属性场景

- 刺激源：外部或内部
- 刺激：事件发生
- 制品：系统的服务
- 环境：
  - 正常
  - 突发事件
  - 过载
- 响应：处理事件，可能改变系统的模式
- 响应测量：
  - 处理事件所花的时间
  - 一定时间内处理事件的个数
  - 处理的错误率/丢失率

#### 策略

##### 资源请求

- 提高计算效率
- 减小计算开销
- 管理事件率
- 控制采样频率
- 限制执行时间
- 限制队列大小

##### 资源管理

- 引入并发
- 维持数据或计算的多个副本
- 增加可用资源

##### 资源仲裁

- 先进先出
- 固定优先级调度
- 动态优先级调度
- 静态调度

### 安全性 (security)

合法用户可用，非法用户不可用

安全性可以表征为提供不可否认性，机密性，完整性，保证，可用性和审计的系统

#### 质量属性场景

- 刺激源：人或系统
- 刺激：一次攻击或破坏安全
- 制品：系统的服务或数据
- 环境：在线或离线、有无防火墙
- 响应：
  - 授权合法用户
  - 拒绝非法用户
  - 监控行为
- 响应测量：
  - 安装 (mount) 各种攻击的难度
  - 从攻击中恢复的难度

#### 策略

##### 抵抗攻击

- 对用户进行身份验证
- 对用户进行授权
- 维持数据的机密性
- 维持数据的完整性
- 限制暴露
- 限制访问

##### 检测攻击

##### 从攻击中恢复

- 恢复状态
- 识别攻击者

### 可测试性 (testability)

易于发现错误的能力

#### 质量属性场景

- 刺激源：
  - 单元测试人员
  - 集合测试人员
  - 系统测试人员
  - 客户
- 刺激：在开发阶段的里程碑
- 制品：
  - 一个设计
  - 一块代码
  - 整个系统
- 环境：
  - 在设计时
  - 在开发时
  - 在编译时
  - 在部署时
- 响应：可以进行测试，可以观察测试结果
- 响应测量：
  - 语句覆盖率
  - 最长测试链的长度
  - 估计找到额外错误的可能性

#### 策略

##### 管理输入/输出

- 记录 / 重放
- 从实现中分离接口
- 分离访问路径 / 接口

##### 内部监控

- 设置监测点 (断点)

### 易用性 (usability)

便于用户完成期望的事情的能力

提供提供的用户支持类型

#### 质量属性场景

- 刺激源：用户
- 刺激：
  - 用户想要有效地使用系统
  - 学习使用系统
  - 最小化错误的影响
  - 适应系统
  - 使用系统感到舒适
- 制品：系统
- 环境：
  - 运行时
  - 系统配置时
- 响应：为用户提供所需的功能或预测用户的需求
- 响应测量：
  - 任务时间
  - 错误的数量
  - 问题解决的数量
  - 用户的满意丢
  - 获得的用户知识
  - 成功操作占总操作的比例
  - 错误发生时时间/数据的花费量

#### 策略

##### 运行时战术

- 维持任务模型
- 维持用户模型
- 维持系统模型

##### 设计时战术

- Model-View-Controller（MVC） 

## 架构权衡分析法 (ATAM)

![1530793847935](C:\Users\dell-pc\AppData\Local\Temp\1530793847935.png)

- 风险 (risks)：可能在将来损害某些质量属性的方案
- 非风险 (non-risks)：可以提高质量、帮助实现目标的决策
- 关键点 / 敏感点 (sensitivity points)：方案中一个小小的变化，就可能对某些质量属性有很大影响 
- 权衡点 (tradeoffs)：影响一个以上质量的决策